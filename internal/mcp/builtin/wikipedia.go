package builtin

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"time"

	mcplib "github.com/mark3labs/mcp-go/mcp"

	"gopus/internal/mcp"
	"gopus/internal/openai"
)

func init() {
	// Register tools with the default tool registry
	mcp.DefaultToolRegistry.Register(
		mcplib.NewTool("search_wikipedia",
			mcplib.WithDescription("Search Wikipedia for a topic and return a summary generated by OpenAI"),
			mcplib.WithString("query",
				mcplib.Required(),
				mcplib.Description("The search query"),
			),
		),
		func(openaiClient *openai.ChatClient) mcp.ToolHandler {
			return wikipediaToolHandler(openaiClient)
		},
	)
}

// wikipediaToolHandler returns a tool handler function that has access to the OpenAI client.
// This pattern allows tools to use the OpenAI API while maintaining the required handler signature.
func wikipediaToolHandler(openaiClient *openai.ChatClient) mcp.ToolHandler {
	return func(ctx context.Context, req mcplib.CallToolRequest) (*mcplib.CallToolResult, error) {
		query, err := GetRequiredStringArg(req, "query")
		if err != nil {
			return nil, err
		}

		// Search Wikipedia for the article
		title, content, err := searchWikipedia(ctx, query)
		if err != nil {
			return mcplib.NewToolResultError(fmt.Sprintf("Wikipedia search failed: %v", err)), nil
		}

		// If no OpenAI client is available, return the raw extract
		if openaiClient == nil {
			result := fmt.Sprintf("# %s\n\n%s", title, content)
			return mcplib.NewToolResultText(result), nil
		}

		// Use OpenAI to generate a summary
		summary, err := generateSummary(ctx, openaiClient, title, content)
		if err != nil {
			// Fall back to raw content if summary generation fails
			result := fmt.Sprintf("# %s\n\n(Summary generation failed: %v)\n\n%s", title, err, content)
			return mcplib.NewToolResultText(result), nil
		}

		result := fmt.Sprintf("# %s\n\n%s", title, summary)
		return mcplib.NewToolResultText(result), nil
	}
}

// wikipediaSearchResponse represents the Wikipedia API search response.
type wikipediaSearchResponse struct {
	Query struct {
		Search []struct {
			Title   string `json:"title"`
			Snippet string `json:"snippet"`
			PageID  int    `json:"pageid"`
		} `json:"search"`
	} `json:"query"`
}

// wikipediaExtractResponse represents the Wikipedia API extract response.
type wikipediaExtractResponse struct {
	Query struct {
		Pages map[string]struct {
			Title   string `json:"title"`
			Extract string `json:"extract"`
		} `json:"pages"`
	} `json:"query"`
}

// searchWikipedia searches Wikipedia for the given query and returns the page content.
func searchWikipedia(ctx context.Context, query string) (string, string, error) {
	httpClient := &http.Client{Timeout: 10 * time.Second}

	// First, search for the article
	searchURL := fmt.Sprintf(
		"https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch=%s&format=json&srlimit=1",
		url.QueryEscape(query),
	)

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, searchURL, nil)
	if err != nil {
		return "", "", fmt.Errorf("failed to create search request: %w", err)
	}
	req.Header.Set("User-Agent", "gopus/1.0 (https://github.com/gopus)")

	resp, err := httpClient.Do(req)
	if err != nil {
		return "", "", fmt.Errorf("failed to search Wikipedia: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", "", fmt.Errorf("failed to read search response: %w", err)
	}

	var searchResult wikipediaSearchResponse
	if err := json.Unmarshal(body, &searchResult); err != nil {
		return "", "", fmt.Errorf("failed to parse search response: %w", err)
	}

	if len(searchResult.Query.Search) == 0 {
		return "", "", fmt.Errorf("no Wikipedia articles found for query: %s", query)
	}

	// Get the page ID and title of the first result
	pageID := searchResult.Query.Search[0].PageID
	title := searchResult.Query.Search[0].Title

	// Now fetch the article extract
	extractURL := fmt.Sprintf(
		"https://en.wikipedia.org/w/api.php?action=query&pageids=%d&prop=extracts&exintro=true&explaintext=true&format=json",
		pageID,
	)

	req, err = http.NewRequestWithContext(ctx, http.MethodGet, extractURL, nil)
	if err != nil {
		return "", "", fmt.Errorf("failed to create extract request: %w", err)
	}
	req.Header.Set("User-Agent", "gopus/1.0 (https://github.com/gopus)")

	resp, err = httpClient.Do(req)
	if err != nil {
		return "", "", fmt.Errorf("failed to fetch Wikipedia extract: %w", err)
	}
	defer resp.Body.Close()

	body, err = io.ReadAll(resp.Body)
	if err != nil {
		return "", "", fmt.Errorf("failed to read extract response: %w", err)
	}

	var extractResult wikipediaExtractResponse
	if err := json.Unmarshal(body, &extractResult); err != nil {
		return "", "", fmt.Errorf("failed to parse extract response: %w", err)
	}

	pageIDStr := fmt.Sprintf("%d", pageID)
	page, ok := extractResult.Query.Pages[pageIDStr]
	if !ok || page.Extract == "" {
		return "", "", fmt.Errorf("no extract found for Wikipedia article: %s", title)
	}

	return title, page.Extract, nil
}

// generateSummary uses the OpenAI client to generate a summary of the Wikipedia content.
func generateSummary(ctx context.Context, client *openai.ChatClient, title, content string) (string, error) {
	systemPrompt := "You are a helpful assistant that summarizes Wikipedia articles concisely. Provide a clear, informative summary in 2-3 paragraphs."
	userPrompt := fmt.Sprintf("Please summarize this Wikipedia article about \"%s\":\n\n%s", title, content)

	messages := []openai.ChatCompletionRequestMessage{
		{
			Role:    openai.RoleSystem,
			Content: &systemPrompt,
		},
		{
			Role:    openai.RoleUser,
			Content: &userPrompt,
		},
	}

	return client.GetMessageContent(ctx, messages)
}
